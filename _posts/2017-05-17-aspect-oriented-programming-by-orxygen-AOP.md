---
layout: post
title: Aspect oriented programmming with oxygen AOP 
#permalink: AOP-With-OxygenAOP/
description: Some Description
date: 2017-05-17 09:17:33 +05:30
tags: "some tags here"
---

# Oxygen.AOP #

Oxygen.AOP is an [Aspect-oriented programming](https://en.wikipedia.org/wiki/Aspect-oriented_programming)
framework which helps maintaining the cross cutting concerns in your codebase well segregated.
It uses Castle.Core Dynamic proxy's capabilities to achieve it.
### Features ###

* It can segregate the cross cutting concerns like logging, data validation, error detection from the business logic of your program.
* You can decorate your business logic method with an attribute and define what happens before the method execution, after the method execution or in error scenarios.

```csharp
[Log]
[ValidateOrder]
public void PlaceOrder(Order orderObj)
{

}
```

### How do I get set up? ###
Suppose we have a method which does some very important business logic work,

```csharp
public int MyVeryImportantBusinessLogicWork(Order order, Customer customer)
{
    UpdateBillingForUser(customer, order);
    PlaceOrderForUser(customer, order);
    NotifyUser(customer);
}
```

But the work is so important we want it to be properly logged and error handled. So we end up writing it like this:

```csharp
public int MyVeryImportantBusinessLogicWork(Order order, Customer customer)
{
    try
    {
        _logger.Log("Order placement started");
        UpdateBillingForUser(customer, order);
        PlaceOrderForUser(customer, order);
        NotifyUser(customer);
        _logger.Log("Order placed for user");
    }
    catch(Exception ex)
    {
        _logger.Log("Order was not complete");
        ApologizeToTheUser();
    }
}
```

As you can see our little method beefed up with some other responsibilities which was not the primary concern of the method itself.

To clean our method `MyVeryImportantBusinessLogicWork` we have to remove the code which is secondary concern of the method. AOP is the way to achieve it. While there are many AOP frameworks to do the job, `Oxygen.AOP` is just one of them.

##### Configuration

Go to [Download](https://bitbucket.org/girishjha/oxygen.aop/downloads) page of the repository and download the binaries. Extract the zip file and refer the Oxygen.AOP.dll in your project.

The library has a base Attribute named `AspectAttribute` which has to be inherited to define your own aspect.
In `Oxygen.AOP` we have an attribute class called `AspectAttribute` which provides the way to define your cross cutting concerns. You need to inherit from this class and override it's members to achieve your cross cutting concern. Suppose we want to our own aspect called `LoggingAspect`.

```csharp
public class LoggingAspect : AspectAttribute
{
//Gets called just before the method call
    public override void OnMethodExecuting(MethodContext invocation)
    {
        _logger.Log("Order placement started");
    }
    //Gets called just after call succeeded
    public override void OnMethodExecuted(MethodExecutedContext invocation)
    {
        Console.WriteLine("From LoggingAspect After call succeeded");
    }
    //Gets called if any exception occurred in the context method
    public override void OnMethodErrored(MethodErroredContext methodContext)
    {
        _logger.Log("Order was not complete");
        methodContext.ReturnValue = 500 error;
    }
}
```

We will decorate our method `MyVeryImportantBusinessLogicWork` with this newly created aspect

```csharp
[LoggingAspect]
public int MyVeryImportantBusinessLogicWork(Order order, Customer customer)
{
    UpdateBillingForUser(customer, order);
    PlaceOrderForUser(customer, order);
    NotifyUser(customer);
}
```

And each of the 3 methods defined in `LoggingAspect` should be called during the execution of the `MyVeryImportantBusinessLogicWork`.
But to make sure this happens we need to take help of `DynamicProxy` from `Castle.Core`.

###### Configuring with StructureMap
If you are using any IOC container like StructrueMap you just need to enrich your instance with the `Interceptor` object defined in `Oxygen.AOP`.
The bootstrapper of StructureMap(version 2.6) looks like this:

```csharp
ObjectFactory.Configure(cfg =>
{
    cfg.For().AlwaysUnique().Use().Named("MyClass");
    cfg.For().AlwaysUnique().Use().Named("Foo");
    cfg.For().EnrichAllWith(instance => ProxyGenerator.CreateInterfaceProxyWithTarget(instance, ProxyGenerationOptions.Default, new Interceptor()));
});
```

As you can see, all the instances of `IFooo` is enriched with an instance of `Interceptor`.

And we are done!

### Dependencies

`Oxygen.AOP` uses the interceptor and proxy class generated by `Castle.Core`.

All the examples shown above is part of tests. For more examples please refer to the tests of the project.